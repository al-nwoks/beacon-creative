name: Simple Remote Deploy

on:
  workflow_dispatch:
    inputs:
      REMOTE_HOST:
        description: 'Remote host or IP (use repository secret REMOTE_HOST if blank)'
        required: false
        default: ''
      REMOTE_USER:
        description: 'SSH user on remote'
        required: false
        default: 'root'
      REMOTE_PATH:
        description: 'Remote path to deploy into (will be created)'
        required: false
        default: '/opt/beacon'
      COMPOSE_FILE:
        description: 'Compose file to use on remote (e.g. docker-compose.prod.yml, docker-compose.yml)'
        required: false
        default: 'docker-compose.yml'
      SERVICES:
        description: 'Which services to (re)deploy: frontend, backend, or all'
        required: false
        default: 'all'
      NO_CACHE:
        description: 'Use --no-cache when building images on the remote (true/false)'
        required: false
        default: 'false'

permissions:
  contents: read

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare variables
        id: vars
        run: |
          REMOTE_HOST="${{ secrets.REMOTE_HOST }}"
          if [ -z "$REMOTE_HOST" ]; then
            echo "ERROR: set repository secret REMOTE_HOST"
            exit 1
          fi
          echo "REMOTE_HOST=$REMOTE_HOST" >> "$GITHUB_OUTPUT"
          echo "REMOTE_USER=${{ github.event.inputs.REMOTE_USER || 'root' }}" >> "$GITHUB_OUTPUT"
          echo "REMOTE_PATH=${{ github.event.inputs.REMOTE_PATH || '/opt/bdc-saas' }}" >> "$GITHUB_OUTPUT"
          echo "COMPOSE_FILE=${{ github.event.inputs.COMPOSE_FILE || 'docker-compose.prod.yml' }}" >> "$GITHUB_OUTPUT"
          echo "SERVICES=${{ github.event.inputs.SERVICES || 'all' }}" >> "$GITHUB_OUTPUT"
          echo "NO_CACHE=${{ github.event.inputs.NO_CACHE || 'false' }}" >> "$GITHUB_OUTPUT"

      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          printf '%s\n' "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          # optional: avoid interactive host key checking in CI
          printf 'Host *\n  StrictHostKeyChecking no\n  UserKnownHostsFile=/dev/null\n' > ~/.ssh/config
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Create archive with artifacts
        run: |
          set -euo pipefail
          ARCHIVE=deploy-package.tar.gz
          rm -f $ARCHIVE
          mkdir -p deploy_payload
          # Copy frontend if present
          if [ -d frontend ]; then
            cp -r frontend deploy_payload/frontend
          fi
          # Copy backend if present (prepare for future implementation)
          if [ -d backend ]; then
            cp -r backend deploy_payload/backend
          fi
          # Copy compose files
          if [ -f docker-compose.prod.yml ]; then cp docker-compose.prod.yml deploy_payload/; fi
          if [ -f docker-compose.yml ]; then cp docker-compose.yml deploy_payload/; fi
          tar -C deploy_payload -czf $ARCHIVE .
          ls -lh $ARCHIVE
        shell: bash

      - name: Upload archive to remote
        run: |
          REMOTE_HOST="${{ steps.vars.outputs.REMOTE_HOST }}"
          REMOTE_USER="${{ steps.vars.outputs.REMOTE_USER }}"
          scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa deploy-package.tar.gz "${REMOTE_USER}@${REMOTE_HOST}:/tmp/"
        shell: bash

      - name: Create remote deploy script
        run: |
          set -euo pipefail
          rm -f ./remote-deploy.sh
          printf '%s\n' '#!/usr/bin/env bash' >> ./remote-deploy.sh
          printf '%s\n' 'set -euo pipefail' >> ./remote-deploy.sh
          printf '%s\n' 'REMOTE_PATH="${REMOTE_PATH}"' >> ./remote-deploy.sh
          printf '%s\n' 'COMPOSE_FILE="${COMPOSE_FILE:-docker-compose.prod.yml}"' >> ./remote-deploy.sh
          printf '%s\n' 'SERVICES="${SERVICES:-all}"' >> ./remote-deploy.sh
          printf '%s\n' 'NO_CACHE="${NO_CACHE:-false}"' >> ./remote-deploy.sh
          printf '%s\n' '# Prepare target' >> ./remote-deploy.sh
          printf '%s\n' 'mkdir -p "${REMOTE_PATH}"' >> ./remote-deploy.sh
          printf '%s\n' 'cd /tmp' >> ./remote-deploy.sh
          printf '%s\n' 'TMPDIR="$(mktemp -d)"' >> ./remote-deploy.sh
          printf '%s\n' 'tar -xzf deploy-package.tar.gz -C "$TMPDIR"' >> ./remote-deploy.sh
          printf '%s\n' 'rsync -a --delete "$TMPDIR/" "${REMOTE_PATH}/"' >> ./remote-deploy.sh
          printf '%s\n' 'rm -rf "$TMPDIR"' >> ./remote-deploy.sh
          printf '%s\n' '# Ensure docker is present' >> ./remote-deploy.sh
          printf '%s\n' 'if ! command -v docker >/dev/null 2>&1; then' >> ./remote-deploy.sh
          printf '%s\n' '  curl -fsSL https://get.docker.com -o get-docker.sh' >> ./remote-deploy.sh
          printf '%s\n' '  sh get-docker.sh' >> ./remote-deploy.sh
          printf '%s\n' '  rm -f get-docker.sh' >> ./remote-deploy.sh
          printf '%s\n' 'fi' >> ./remote-deploy.sh
          printf '%s\n' '# Ensure docker compose' >> ./remote-deploy.sh
          printf '%s\n' 'if docker compose version >/dev/null 2>&1; then' >> ./remote-deploy.sh
          printf '%s\n' '  COMPOSE="docker compose"' >> ./remote-deploy.sh
          printf '%s\n' 'elif command -v docker-compose >/dev/null 2>&1; then' >> ./remote-deploy.sh
          printf '%s\n' '  COMPOSE="docker-compose"' >> ./remote-deploy.sh
          printf '%s\n' 'else' >> ./remote-deploy.sh
          printf '%s\n' '  curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose' >> ./remote-deploy.sh
          printf '%s\n' '  chmod +x /usr/local/bin/docker-compose' >> ./remote-deploy.sh
          printf '%s\n' '  COMPOSE="docker-compose"' >> ./remote-deploy.sh
          printf '%s\n' 'fi' >> ./remote-deploy.sh
          printf '%s\n' 'cd "${REMOTE_PATH}"' >> ./remote-deploy.sh
          printf '%s\n' '# Determine services list (empty means all services)' >> ./remote-deploy.sh
          printf '%s\n' 'if [ "$SERVICES" = "all" ] || [ -z "$SERVICES" ]; then' >> ./remote-deploy.sh
          printf '%s\n' '  SERVICES_ARG=""' >> ./remote-deploy.sh
          printf '%s\n' 'else' >> ./remote-deploy.sh
          printf '%s\n' '  SERVICES_ARG="$SERVICES"' >> ./remote-deploy.sh
          printf '%s\n' 'fi' >> ./remote-deploy.sh
          printf '%s\n' '# Build (with or without cache) and start the requested services' >> ./remote-deploy.sh
          printf '%s\n' 'if [ "$NO_CACHE" = "true" ]; then' >> ./remote-deploy.sh
          printf '%s\n' '  if [ -z "$SERVICES_ARG" ]; then' >> ./remote-deploy.sh
          printf '%s\n' '    $COMPOSE -f "$COMPOSE_FILE" build --no-cache' >> ./remote-deploy.sh
          printf '%s\n' '  else' >> ./remote-deploy.sh
          printf '%s\n' '    $COMPOSE -f "$COMPOSE_FILE" build --no-cache $SERVICES_ARG' >> ./remote-deploy.sh
          printf '%s\n' '  fi' >> ./remote-deploy.sh
          printf '%s\n' '  $COMPOSE -f "$COMPOSE_FILE" up -d $SERVICES_ARG' >> ./remote-deploy.sh
          printf '%s\n' 'else' >> ./remote-deploy.sh
          printf '%s\n' '  $COMPOSE -f "$COMPOSE_FILE" up -d --build $SERVICES_ARG' >> ./remote-deploy.sh
          printf '%s\n' 'fi' >> ./remote-deploy.sh
          printf '%s\n' 'echo "Deployed services: ${SERVICES_ARG:-all} using compose file: ${COMPOSE_FILE}"' >> ./remote-deploy.sh
          chmod +x ./remote-deploy.sh
        shell: bash

      - name: Upload deploy script and archive to remote
        run: |
          REMOTE_HOST="${{ steps.vars.outputs.REMOTE_HOST }}"
          REMOTE_USER="${{ steps.vars.outputs.REMOTE_USER }}"
          scp -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa deploy-package.tar.gz remote-deploy.sh "${REMOTE_USER}@${REMOTE_HOST}:/tmp/"
        shell: bash

      - name: Execute remote deploy script
        run: |
          REMOTE_HOST="${{ steps.vars.outputs.REMOTE_HOST }}"
          REMOTE_USER="${{ steps.vars.outputs.REMOTE_USER }}"
          REMOTE_PATH="${{ steps.vars.outputs.REMOTE_PATH }}"
          COMPOSE_FILE="${{ steps.vars.outputs.COMPOSE_FILE }}"
          SERVICES="${{ steps.vars.outputs.SERVICES }}"
          NO_CACHE="${{ steps.vars.outputs.NO_CACHE }}"
          # Export variables into the remote command so the remote script can read them
          ssh -o StrictHostKeyChecking=no -i ~/.ssh/id_rsa "${REMOTE_USER}@${REMOTE_HOST}" \
            "REMOTE_PATH='${REMOTE_PATH}' COMPOSE_FILE='${COMPOSE_FILE}' SERVICES='${SERVICES}' NO_CACHE='${NO_CACHE}' bash /tmp/remote-deploy.sh"
        shell: bash

      - name: Cleanup local artifact
        if: always()
        run: |
          rm -f deploy-package.tar.gz
          rm -rf deploy_payload
